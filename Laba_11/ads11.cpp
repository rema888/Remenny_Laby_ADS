#include <iostream> 

void QuickSort(int arr[], int left, int right) 
{
    if(left > right)  // условие выхода из рекурсии, когда подмассив пуст или подмассив содержит 1 элемент
        return;

    int p = arr[(left + right) / 2]; // Выбор опорного элемента

    int i = left; // индекс i указывает на левую границу, сначала i у первого элемента
    int j = right; // индекс j указывает на правую границу, сначала j у последнего элемента

    while (i <= j) // пока индексы не разойдутся
    {
        while(arr[i] < p) i++; // перемещаем i вправо, пока не найдем элемент, больший или равный опорному
        while(arr[j] > p) j--; // перемещаем j влево, пока не найдем элемент, меньший или равный опорному
        if (i <= j) // когда отсортируем 1 раз массив и индекс j будет левее, а индекс i будет правее
                    // те элементы что левее j - меньше или равны опорному, те что правее i - больше или равны опорному
        {
            int tmp = arr[i]; // меняем местами элементы с индексами i и  j
            arr[i] = arr[j];
            arr[j] = tmp;
            i++; // продвигаем i на один шаг а j уменьшаем
            j--;
        }
    }
    // i стал больше j 
    QuickSort(arr, left, j); // для каждой из полученных частей вызываем QuickSort отдельно
    QuickSort(arr, i, right);
}

int main()
{
    const int X = 20;
    int arr[X];

    std::cout << "Исходный массив: " << std::endl;
    for (int i=0;i<X;i++)
    {
        arr[i] = rand() % 500;
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    
    QuickSort(arr, 0, X-1);
    std::cout << "Отсортированный массив: " << std::endl;
    for (int i=0;i<X;i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

}